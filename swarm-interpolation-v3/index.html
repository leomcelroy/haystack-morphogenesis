<!DOCTYPE html>
<html lang="en">
  <meta charset="utf-8" />
  <style>
    body{
      margin:0px;
    }
    canvas{
      margin:5px;
    }
  </style>
  <body>
    <div id="root"></div>
  </body>
  <script src="three/three.js"></script>
  <script src="three/OrbitControls.js"></script>
  <script src="findContours.js"></script>
  <script src="earcut.js"></script>
  <script src="script.js"></script>
  <script type="module">
    import { html, render } from "./uhtml.js";
    import { distanceTransform } from "./distanceTransform.js";
    import { shape_morph_multi } from "./shape_morph_multi.js";
    import { sdf } from "./sdf.js";
    import { shade } from "./shade.js";
    import { marchingCubes } from "/helpers/marching-cubes.js";
    import { addEvents } from "./events.js";

    const IMAGE_WIDTH = 128;
    const IMAGE_HEIGHT = 128;
    const HEIGHT = 100;

    const state = {
      image_width: IMAGE_WIDTH,
      image_height: IMAGE_HEIGHT,
      height: HEIGHT,
      slices: [ // depth, pixels
        [ 0, new Uint8ClampedArray(IMAGE_WIDTH * IMAGE_HEIGHT * 4) ],
        [ 50, new Uint8ClampedArray(IMAGE_WIDTH * IMAGE_HEIGHT * 4) ],
        [ HEIGHT, new Uint8ClampedArray(IMAGE_WIDTH * IMAGE_HEIGHT * 4) ],
      ],
      selectedSlice: 0,
      editableCanvasData: null,
    }

    const drawNode = (x, i) => html`
      <div
        class=${[
          "slice-node", 
          state.selectedSlice === i ? "selected-slice" : ""
        ].join(" ")}
        data-index=${i}
        data-depth=${x[0]}
        @mousedown=${() => {
          state.selectedSlice = i;
          r();
        }}
        style=${`top:${x[0]/state.height*100}%;`}>
      </div>
    `

    const drawSlice = (x) => {
      console.log(state.slices, state.selectedSlice);
      return html`
        <canvas 
          width=${state.image_width} 
          height=${state.image_height}
          class=${[
            "slice",
            "editable-canvas",
            state.slices[state.selectedSlice][0] === x[0] ? "selected-slice" : ""
          ].join(" ")}
          @mousedown=${() => {
            const heights = state.slices.map(slice => slice[0]);
            const i = heights.indexOf(x[0]);
            state.selectedSlice = i;
            r();
          }}>
        </canvas>
      `
    }

    const view = () => {

      return html`
        <link rel="stylesheet" href="/swarm-interpolation-v3/styles.css">
        <div class="model-viewer">3d model</div>
        <div class="slider">
          <div class="slider-bar"> ${state.slices.map(drawNode)}</div>
         
        </div>
        <div class="right-panel">
          <div class="slices">${state.slices.map(drawSlice)}</div>
          <div class="buttons">
            <button>run</button>
            <button>delete</button>
          </div>
        </div>
    `
    }

    function drawCanvases() {
      let cnvs = document.querySelectorAll(".editable-canvas");

      for (let i = 0; i < state.slices.length; i++) {
        const cnv = cnvs[i];
        const ctx = cnv.getContext('2d');
        const data = state.slices[i][1];

        const img = new ImageData(
          data, 
          state.image_width, 
          state.image_height
        );
        ctx.putImageData(img, 0 , 0);
      }
    }

    const r = () => {
      render(document.body, view());
      drawCanvases();
    }

    window.RENDER = r;


    function init(state) {
      r();
      // setCanvasData(state.selectedSlice);
      // addCanvasDrawing();

      addEvents(state);
    }

    init(state);

    let animIndex = 0;
    let animStep = 1;

    function animate() {
      const images = document.querySelectorAll(".snapshots > *");
      const c = document.querySelector(".sequence-anim");
      const ctx = c.getContext("2d");
      const image = images[animIndex];
      if (!image) return;
      ctx.drawImage(image, 0, 0);
      if (animIndex === images.length-1) animStep = -1;
      if (animIndex === 0) animStep = 1;
      animIndex = (animIndex + animStep) % images.length;
    }

    // setInterval(animate, 1000/30);

    function renderImage(imageData) {
      const c = document.createElement("canvas");
      const ctx = c.getContext("2d");
      c.width = imageData.width;
      c.height = imageData.height;
      ctx.putImageData(imageData, 0, 0);

      const container = document.querySelector(".snapshots");

      container.append(c);
    }

    const lerp = (x, y, a) => x * (1 - a) + y * a;

    const invert = image => {
      for (let i = 0; i < image.width * image.height * 4; i++) {
        image.data[i] = 255 - image.data[i];
      }

      return image;
    }

    function interpolateSlices(slice0, slice1, width, height, a) {
      const interpolated = new Float32Array(width * height);
      for (let i = 0; i < width * height; i++) {
        const d0 = slice0[i];
        const d1 = slice1[i];
        interpolated[i] = lerp(d0, d1, a); 
      }

      console.log(interpolated);
      return interpolated;
    }

    function getBoundingFieldsIndicies(h) {
      // []
      const heights = state.slices.map(x => x[0]);
      let minIndex = -1;
      let minDist = Infinity;
      let maxIndex = -1;
      let maxDist = Infinity;

      for (let i = 0; i < heights.length; i++) {
        const currentHeight = heights[i];
        if (h >= currentHeight && Math.abs(h - currentHeight) <= minDist) {
          minDist = Math.abs(h - currentHeight);
          minIndex = i;
        }

        if (h <= currentHeight && Math.abs(h - currentHeight) <= maxDist) {
          maxDist = Math.abs(h - currentHeight);
          maxIndex = i;
        }
      }

      return [minIndex, maxIndex];
    }

    function display_canvas(A,w,h){
      let cnv = document.createElement("canvas");
      cnv.width = w;
      cnv.height = h;
      let ctx = cnv.getContext('2d');
      ctx.fillRect(0,0,cnv.width,cnv.height);
      ctx.fillStyle="white";
      for (let i = 0; i < h; i++){
        for (let j = 0; j < w; j++){
          if (A[i*w+j]) ctx.fillRect(j,i,1,1);
        }
      }
      return cnv;
    }

    function typedArrayToBin(arr) {
      const result = [];
      for (let i = 0; i < arr.length; i +=4 ) {
        const val = arr[i];
        result.push(val > 128 ? 1 : 0);
      }

      return result;
    }

    function binToTypedArray(arr) {
      const result = new Uint8ClampedArray(arr.length*4);
      for (let i = 0; i < arr.length; i += 1 ) {
        const val = arr[i];
        result[i*4] = val*255;
        result[i*4+1] = val*255;
        result[i*4+2] = val*255;
        result[i*4+3] = 255;
      }

      return result;
    }

    function interpolateWithSwarm() {
      const sdfs = [];
      const sortedSlices = state.slices.slice().sort((a, b) => a[0] - b[0]);

      const Ts = shape_morph_multi(
        sortedSlices.map(([ height, x ]) => typedArrayToBin(x)),
        sortedSlices.map(([ height, x ]) => ~~height),
        image_width,
        image_height,
        4
      ).map(binToTypedArray);


      for (let i = 0; i < Ts.length; i++) {
        const slice = Ts[i];
        const image = new ImageData(slice.slice(), image_width);
        const pos = distanceTransform(image);
        const neg = distanceTransform(invert(image));
        const combined = new Float32Array(image.width * image.height);
        let max = -9999999;
        let min = 99999999;
        for (let i = 0; i < pos.length; i++) {
          combined[i] = pos[i] - neg[i];
          max = Math.max(max, combined[i]);
          min = Math.min(min, combined[i]);
        }
        sdfs.push({ data: combined, max, min });
        const s = shade(combined, image_width, image_height, max, min);
        renderImage(s);
      }

      return sdfs;
    }

    function interpolateWithSDFs() {
      let sdfs = []

      for (let i = 0; i < state.slices.length; i++) {
        const [ height, slice ] = state.slices[i];
        const image = new ImageData(slice.slice(), image_width);
        const pos = distanceTransform(image);
        const neg = distanceTransform(invert(image));
        const combined = new Float32Array(image.width * image.height);
        let max = -9999999;
        let min = 99999999;
        for (let i = 0; i < pos.length; i++) {
          combined[i] = pos[i] - neg[i];
          max = Math.max(max, combined[i]);
          min = Math.min(min, combined[i]);
        }
        sdfs.push({ data: combined, max, min });
        const s = shade(combined, image_width, image_height, max, min);
      }

      const heights = state.slices.map(x => x[0]);

      for (let i = 0; i <= height; i += 1) {
        // need to get sdfs of the bounding heights
        const [index0, index1] = getBoundingFieldsIndicies(i);
        const h0 = heights[index0];
        const h1 = heights[index1];
        const a = (i-h0)/(h1-h0);

        const  { data: slice0, max: max0, min: min0 } = sdfs[index0];
        const  { data: slice1, max: max1, min: min1 } = sdfs[index1];
        let max = Math.max(max0, max1);
        let min = Math.min(min0, min1);
        const slice = a === 0 || isNaN(a) 
          ? slice0
          : interpolateSlices(slice0, slice1, image_width, image_height, a);
        const s = shade(slice, image_width, image_height, max, min);
        renderImage(s);
      }

      return sdfs
    }

    function onClickRun() {
      const container = document.querySelector(".snapshots");
      container.innerHTML = "";

      const sdfs = interpolateWithSwarm().map(x => x.data);
      // interpolateWithSDFs();

      console.log(sdfs);
      marchingCubes(sdfs, image_width, 0);
      

      // get distance field of each slice
      // make voxel distance field by interpolating for each layer
      
      // or
      // generate slices by intepolating between layers to make intermediate distance fields

    }

  </script>
</html>
